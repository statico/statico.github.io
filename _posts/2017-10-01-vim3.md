---
draft: true
layout: post
title: Vim After 15 Years
description: XXX
image: /images/vim/vim3.png
---

It's been about four years since my earlier [Vim After 11 Years](/vim.html) post, which was well-received. I've been writing a lot of more code with Vim lately and I figured that it was about time for an update.

Since my previous post my core configuration hasn't changed much. However, the last few years have seen impressive growth in the Vim community. There have been an advent of new plugins, new Vim features (like asynchronous operations), and a new website to let us explore new plugins.

<figure>
<a href="/images/vim/vim3.png"><img src="/images/vim/vim3.png"/></a>
<figcaption>A recent Vim session</figcaption>
</figure>

### On Plugins

There always seems to be a backlash against using Vim with lots of plugins.  Part of this is understandable suspicion -- any system which allows users to add unordered extensions to patch itself without hesitation can easily become a mess. Just look at WordPress. Or, if you were around 20 years ago, try remembering extensions in Mac OS Classic, which were patches on top of patches. With these systems there's no formal way to declare dependencies and debugging incompatibilities becomes the norm.

Vim plugins aren't that bad. Debugging an interaction between plugins _X_ and _Y_ usually involves googling "vim X with Y." It's certainly not as bad as binary-searching your way through extension conflicts like [Conflict Catcher](https://tidbits.com/article/1496) used do on Mac OS Classic.

I only found one bad interaction between plugins so far: with the [vim-css-jsx](https://github.com/alampros/vim-styled-jsx) and [vim-polyglot](XXX) plugins, I had to rename one plugin so it [loaded before the other](https://github.com/alampros/vim-styled-jsx/issues/1). I'm not proud of that solution, but so far it appears to be the only plugin-ordering problem I've encountered.

Further resistance towards plugins seems to a kind of purist animosity against straying away from some _core set_ of Vim functionality. However, if you use Vim, you're already in a subset of people who demand that editing text be fast and efficient, so this is like a group of savants arguing about which of them is more eccentric. If you use one of the movement plugins like [EasyMotion](https://vimawesome.com/plugin/easymotion) or [vim-sneak](https://vimawesome.com/plugin/vim-sneak) then probably agree that the tool you're using is more efficient than vanilla Vim, and those users think that using Vim is more efficient than the other text editors the larger set of people in the world are using. And so on.

Plugins have always been a part of Vim. With the recent improvements to Vim and VimL, such as [asynchronous process control](https://vimhelp.appspot.com/channel.txt.html) and [useful types](https://vimhelp.appspot.com/version7.txt.html#new-7), the plugin ecosystem is thriving. A new plugin site, [VimAwesome](https://vimawesome.com/), shows the most popular plugins as well, lets your browse and search, and has well-formatted documentation and install instructions using the myriad of plugin managers that now exist.

My opinion on plugins is thus: If a plugin provides useful functionality that I wish were built into Vim, it's worth installing. Otherwise, I try to keep the number of plugins at a minimum to avoid interaction problems and maintain crisp performance when starting Vim and viewing files. Thus, the plugins and configuration I list here are more about efficiency and getting stuff done instead of difference for the sake of difference.

### fzf

TextMate and Sublime Text taught us that the fastest way to go from firing neurons to viewing a file is by _fuzzy finding_, or rather, typing part of a filename or path to open a file, even if the characters aren't adjacent or you making a spelling error. This is such a useful navigation technique that it's become a standard feature on modern editors.

[Ctrl-P](https://vimawesome.com/plugin/ctrlp-vim-everything-has-changed) has been the reigning champ for years, but new tool, [fzf](https://github.com/junegunn/fzf), is much faster and thus more forgiving when trying to find one file or tag among thousands. Ctrl-P used to do OK on a 30,000-file codebase on my 2013-era MacBook Pro, but it really started to croak during a fuzzy search of our enormous tags file and was slow to the point of being unusable. fzf, however, shows no speed difference between files or tags -- it's blazingly fast either way.

XXX gif of using fzf

Getting started with fzf is pretty easy. Simply follow the [installation instructions](https://github.com/junegunn/fzf#installation) (basically `brew install fzf` on macOS with [Homebrew](https://brew.sh/)) and install the additional [fzf.vim](https://github.com/junegunn/fzf.vim) for badass lightspeed functionality.

fzf, which is an editor- and platform-independent utility, comes with a basic Vim plugin. However, its functionality is minimal, so a nice person wrote [fzf.vim](https://github.com/junegunn/fzf.vim) which provides all of the functionality you'd expect coming from Ctrl-P or a similar utility. fzf.vim has commands to search most everything from Vim, but the most useful commands are `:Files` and `:Buffers`, which I've bound to <kbd>,</kbd><kbd>t</kbd> and <kbd>;</kbd>: 

```vim
nmap ; :Buffers<CR>
nmap <Leader>t :Files<CR>
nmap <Leader>r :Tags<CR>
```

Binding <kbd>;</kbd> is important to me because I live and breathe in buffers -- I practically never use tabs, more on that later -- so it's important that I be able to switch focus to something I'm thinking of with as little friction as possible.

Don't forget the previous post where I [talked about](/vim.html#ctrl-e) binding <kbd>Ctrl-E</kbd> to swapping to the previously-opened buffer -- it's normally bound to <kbd>Ctrl-Shift-6</kbd>, but I found that hard to remember and type, so I rebound it to <kbd>Ctrl-E</kbd>. Also make sure you know about [<kbd>Ctrl-o</kbd>](https://vimhelp.appspot.com/motion.txt.html#CTRL-O), XXXXXX REMOVE

When using fzf, make sure to configure it to use `ag`, a `grep`/`ack` replacement called the [Silver Searcher](https://github.com/ggreer/the_silver_searcher), which will in turn respect your `.gitignore` and your `.agignore` files. You no longer need to keep a giant `wildignore` string in your `vimrc`! (Though if you still want to do that, consider the [RootIgnore](https://vimawesome.com/plugin/rootignore) plugin which configures `wildignore` according to your `.gitignore`.) The point is, `ag` is blisteringly fast, and FZF can make use of what you've already configured. Here's the snippet from my [.zshrc](https://github.com/statico/dotfiles/blob/340c01d0970bc2cd6a27284ddb87774131c00e5c/.zshrc#L812-L829):

```bash
if [ -e /usr/local/opt/fzf/shell/completion.zsh ]; then
  source /usr/local/opt/fzf/shell/key-bindings.zsh
  source /usr/local/opt/fzf/shell/completion.zsh
fi
if [ -e ~/.fzf ]; then
  _append_to_path ~/.fzf/bin
  source ~/.fzf/shell/key-bindings.zsh
  source ~/.fzf/shell/completion.zsh
fi
if _has fzf && _has ag; then
  export FZF_DEFAULT_COMMAND='ag --nocolor -g ""'
  export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
  export FZF_ALT_C_COMMAND="$FZF_DEFAULT_COMMAND"
  export FZF_DEFAULT_OPTS='
  --color fg:242,bg:236,hl:65,fg+:15,bg+:239,hl+:108
  --color info:108,prompt:109,spinner:108,pointer:168,marker:168
  '
fi
```

fzf works in the shell, too, and comes with bindings for Zsh, Bash, and the Fish shell. In Zsh, I can hit <kbd>Ctrl-t</kbd> to instantly fuzzy-find any file in the current directory. And since I've configured fzf to use `ag`, it'll ignore anything excluded by `.gitignore`. It's glorious.

I had originally written about the one big drawback to fzf being that it didn't work with MacVim. But the authors have recently [fixed this](https://github.com/junegunn/fzf.vim/issues/416#issuecomment-327982805) by using [the new built-in terminal in Vim 8](https://vimhelp.appspot.com/terminal.txt.html), and it works swimmingly.

#### An aside on fuzzy-finding

While FZF and Ctrl-P and other editors support fuzzy searching for pathnames, I'm really hoping that someone will implement a first-character search for Vim. For example, in IntelliJ, if you want to open the class `FooFactoryGeneratorBean` all you have to do is hit <kbd>Cmd-o</kbd> and type <kbd>F</kbd><kbd>F</kbd><kbd>G</kbd><kbd>B</kbd><kbd>Enter</kbd> to open it. This would be handy for searching tags as class names are often camel case regardless of language. Maybe it could treat characters before underscores as the first character so typing something like <kbd>f</kbd><kbd>b</kbd><kbd>b</kbd><kbd>q</kbd> would highlight a file like `foo_bar_baz_quux.js`. Just throwing that out there.

### Searching & the QuickFix window

If FZF is the new way to locate and act upon a _single_ path, `ag` is the new way to act upon _multiple_ paths. In other words, `ag` is the new `ack`, which was the new `grep`. The best way to use `ag` from within Vim seems to be [ack.vim](https://vimawesome.com/plugin/ack-vim), which is misleading since [ag.vim is deprecated](https://github.com/rking/ag.vim/issues/124#issuecomment-227038003), but ack.vim supports both `ack` and `ag`.

ack.vim gives you an `:Ack` command. It takes arguments in the same way as running `ag` from the command line, except that it opens the QuickFix window with the list of search results:

XXX image of using :Ag and QuickFix

Note that `:Ack` by default will jump to the first result in the QuickFix list. If you don't want this to happen, use `:Ack!`, or reverse the functionality of the two commands [per the docs](https://github.com/mileszs/ack.vim#i-dont-want-to-jump-to-the-first-result-automatically).

The most obvious way to use the QuickFix window is to moving the cursor there and hitting <kbd>Enter</kbd> to open a result. The `:cnext` and `:cprev` commands also move and up down the results, and I tried to find a cross-platform keybinding I liked for these for a while. Then I discovered [vim-unimpaired](https://vimawesome.com/plugin/unimpaired-vim), which adds useful bindings like <kbd>[</kbd><kbd>q</kbd> and <kbd>]</kbd><kbd>q</kbd> for `:cprev` and `:cnext`, which cycle to the previous and first QuickFix search result, respectively. vim-unimpaired actually has a lot more bindings for next/previous pairs, like navigating compiler/linter errors and toggling common options like line numbers.

Using the QuickFix window for search results so useful that I wrote a few bindings which search for the current word under the cursor:

```vim
nmap <M-k>    :Ack! "\b<cword>\b" <CR>
nmap <Esc>k   :Ack! "\b<cword>\b" <CR>
nmap <M-S-k>  :Ggrep! "\b<cword>\b" <CR>
nmap <Esc>K   :Ggrep! "\b<cword>\b" <CR>
```

`exhuberant-ctags` is only so-so at finding tags in Ruby and CoffeeScript, and sometimes you just need to search for that damned word that you're already staring at.

XXX gif of using Meta-k

Finally, after I'm done searching and navigating, I hit <kbd>\</kbd><kbd>x</kbd> (bound to `:cclose`) to close the QuickFix window. I'll probably want to navigate back to the original file I was looking at, and I usually hit <kbd>Ctrl-o</kbd> a few times, which [jumps backward in the jump list](https://vimhelp.appspot.com/motion.txt.html#CTRL-O) and is basically like hitting the Back button in a browser.  Other times I'll use <kbd>;</kbd> to bring up the buffer list. And now that I'm thinking about it, maybe I'll modify the binding set a [global mark](https://vimhelp.appspot.com/motion.txt.html#%270) in my <kbd>Meta-k</kbd> binding, like `o`, so that <kbd>'</kbd><kbd>O</kbd> will always take me back to where I started.

### Terminals, panes, and multiplexing

I mentioned before that I'm not a heavy gvim/MacVim user. I strongly prefer to work in a terminal, but there are some good reasons to use a standalone Vim application:

1. It's more responsive than Vim inside tmux
1. It's a better default application than TextEdit to open `.txt` files on macOS
1. It doesn't have a problem [clicking past the 220th column](https://stackoverflow.com/q/7000960/102704)
1. You're writing a long blog post with lots of spelling errors and for some damned reason Vim inside you terminal with your favorite font [won't show underlines](https://github.com/fabrizioschiavi/pragmatapro/issues/14)
1. Adherence to purity requires you to use the _true_ Solarized color scheme instead of the blasphemous scheme created when Solarized is [quantized to 256 colors](http://ethanschoonover.com/solarized/vim-colors-solarized#important-note-for-terminal-users)

A big reason to use Vim in a terminal is [tmux](https://github.com/tmux/tmux/wiki/FAQ). A lot of people use tmux to do remote development, but it's just wonderful for local development. As of now, tmux is now my fullscreen working environment, and Vim usually takes up one of the tmux panes. This lets use Vim while keeping a few other shells open -- usually a server and one or two other utility panes. Full-screen Vim is sometimes useful, and tmux lets you temporarily zoom a pane with <kbd>&lt;prefix&gt;</kbd><kbd>z</kbd>.

The killer feature is the ability to [send keys](http://minimul.com/increased-developer-productivity-with-tmux-part-5.html) to other tmux panes. That means I can set up a fancy REPL loop like an IDE -- I can edit in one pane and execute commands and see results in another pane, plus I can keep the server log visible in case there are any errors. For example, if I'm working on a REST, I can re-test the endpoint with `curl` and view the output with [jq](https://stedolan.github.io/jq/) using a few keystrokes:

XXX gif of testing aspen endpoint with tmux and curl+jq

The normal loop would be to make a change in Vim, hit <kbd>:</kbd><kbd>w</kbd><kbd>Enter</kbd> to save, the <kbd>Ctrl-t</kbd><kbd>h</kbd> to move to the left pane, then <kbd>Up</kbd><kbd>Enter</kbd> to repeat the command, and <kbd>Ctrl-t</kbd><kbd>l</kbd> to go back to Vim. But a simple keybinding in Vim can accomplish that much more quickly -- I used <kbd>\</kbd><kbd>r</kbd> as in "run" or "repeat":

```vim
nmap \r :!tmux send-keys -t 0:0.1 C-p C-j <CR><CR>
```

To explain, this executes the `tmux send-keys` command which tells it to send keys to session, window and pane (`0:0.1`) where I had run `curl` previously. It then sends <kbd>Ctrl-j</kbd>, which is equivalent to hitting <kbd>Up</kbd>, which pulls the previous command from history, and then <kbd>Enter</kbd> to execute it.

I've been using this for half a year and it's been a massive improvement to my productivity. However, it's worth mentioning that Vim 8 now supports [in-editor native terminals](https://vimhelp.appspot.com/terminal.txt.html), and they're pretty good. While various plugins have tried to integrate terminals into Vim before, usually with lackluster results, the new native terminals are fast, Unicode-aware, and 256 color-enabled, and there's a new `term_sendkeys()` function that lets you send keystrokes. This was only added to Vim a few months ago, so I need to experiment, but who knows -- I might end up using MacVim splits with `:terminal`s instead of tmux.

#### A note on terminals on macOS

I've been using [iTerm2](https://www.iterm2.com/) instead of macOS's default Terminal.app since forever. However, I recently noticed that typing in Vim inside iTerm2 felt a bit sluggish, especially Vim inside tmux. As a comparison I tried using `urxvt` inside XQuartz and it felt like lightning, so something was clearly adding latency. But I wasn't about to make `urxvt` my primary terminal on macOS because of the clipboard woes, focus issues, and lack of high-DPI support on XQuartz.

Coincidentally, a few days after noticing this, I read [an article](https://danluu.com/term-latency/) that demonstrated input latency between terminals and pointed out that Terminal.app is now significantly faster than iTerm2. I tried it for myself and confirmed that the keystroke latency was somewhere between urxvt and iTerm2, so I've switched to Terminal.app completely. I don't miss iTerm2's vertical splits as much since I'm using tmux. (Yes, I've tried iTerm2's tmux integration, but I never really saw how it was helpful.) Also, I was using a fancy [custom iTerm2 color theme](https://github.com/mbadolato/iTerm2-Color-Schemes) and was pleased to find a project which has [converted all the themes](https://github.com/lysyi3m/osx-terminal-themes) for Terminal.app.

Oh, I lied a little. I do miss one thing about iTerm2 vertical splits: the very occasional use case where I want a different font sizes in different panes. Sometimes I want the editor font size larger and the server output smaller to fit more lines on the screen. It's easy to do this with iTerm2, or in fact _any_ editor environment where the editing area isn't a single grid with fixed sized cells.

### Writing prose in Vim

Distraction-free writing is popular and for good reason -- it works. I want to do my writing in Vim, however, and not some external app. So what's the solution?

<figure>
<a href="/images/vim/vim3-prose.png"><img src="/images/vim/vim3-prose.png"/></a>
</figure>

A great plugin is [goyo.vim](https://vimawesome.com/plugin/goyo-vim), which adds lots of padding to your buffer and hides all the cruft. It's also aware of airline/powerline/lightline status bars, so those get hidden too ([well, mostly](https://github.com/itchyny/lightline.vim/issues/83)). I've combined that with a few other custom settings which I call **Prose Mode**:

```vim
function! ProseMode()
  call goyo#execute(0, [])
  set spell noci nosi noai nolist noshowmode noshowcmd
  set complete+=s
  set bg=light
  if !has('gui_running')
    let g:solarized_termcolors=256
  endif
  colors solarized
endfunction
command! ProseMode call ProseMode()
```

This function turns on Goyo and gets rid of any funny source-code like indenting when you type parentheses. It changes the color scheme from my regular dark theme to the light version of Solarized. Changing the theme is important because it becomes a visual reminder that I'm in "writing mode" and, unlike when I'm coding, I shouldn't mess around or get distracted since my goal is to produce words.

The function also makes autocompletion pull words from the thesaurus and dictionary when I hit <kbd>Tab</kbd> to hopefully write faster. This is still a work-in-progress, but it's come in handy here and there.

### Linting

One of best additions to Vim 8 is [asynchronous process control](https://vimhelp.appspot.com/channel.txt.html). This was the most sorely needed feature in Vim and it is wonderful it has finally been implemented.

Now that Vim can finally run processes in the background, a good new plugin called [ALE](https://vimawesome.com/plugin/ale) is gaining on [Syntastic](https://vimawesome.com/plugin/syntastic) because it runs the linters asynchronously. You no longer have to wait on each file write. I've been writing a lot of Ruby/JRuby this past year, which takes a while to spin up, and I had turned Syntastic off because of the delays. But with ALE I can now turn linting back on.

### Lightline, Powerline, Airline, and status bars

I was using Powerline for the last few years, and recently the newer, lighter-weight [Airline](https://vimawesome.com/plugin/vim-airline) has replaced it. I began to feel that the information and widgets in these status bars are more distracting than useful, so I switched to [Lightline](https://vimawesome.com/plugin/lightline-vim) and spent [a little effort](https://github.com/statico/dotfiles/blob/202e30b23e5216ffb6526cce66a0ef4fa7070456/.vim/vimrc#L406-L453) to customize it. I want minimal information and distractions, but I want to see the number of errors and warnings when things are wrong. I don't need to know the current file encoding or syntax.

XXX image of lightline with linting

I still don't get why everyone wants to see the current git branch in their editor's status line and in their shell prompt -- I feel like I always know what branch I'm on, and with shells it can be inaccurate if you've switched branches in a different shell. But, clearly I'm the odd man out here, and maybe I'll see the light.

### Git

If you're using Git, a few plugins are important.

[vim-gitgutter](https://vimawesome.com/plugin/vim-gitgutter) is a plugin that shows you markers for any lines that have been added, delete, or modified. Most editors do this nowadays. I customized it to show me a colored dot (`Â·`) for each line change, which I think looks a lot cleaner than the default `+` and `-` characters.

<figure>
<a href="/images/vim/vim3-gitgutter.png"><img src="/images/vim/vim3-gitgutter.png"/></a>
</figure>

[vim-fugitive](https://vimawesome.com/plugin/fugitive-vim) is currently the most popular Git plugin for Vim and has lots of capability. I rarely use anything other than `:Gblame` and `:Gbrowse`, but it's got a lot of other nice things you'd expect from in-editor Git tools. (If your repo is hosted on GitHub you'll need [vim-rhubarb](https://vimawesome.com/plugin/vim-rhubarb) to get `:Gbrowse` to work.)

`:Gbrowse` is wonderful -- it opens the current file with optional line selection in the browser (assuming the repo is mirrored on GitHub or GitLab or whatever). Note that GitHub now displays links to specific commits and line numbers as snippets when used in issues and pull requests. So all you have to is select a few lines with <kbd>Shift-v</kbd>, run `:Gbrowse`, copy the URL that opens, and paste it into a GitHub comment to get something like this:

<figure>
<a href="/images/vim/vim3-github.png"><img src="/images/vim/vim3-github.png"/></a>
</figure>

Finally, I thought I was going to talk about [RootIgnore](https://vimawesome.com/plugin/rootignore) and how it sets the `wildignore` automatically based on your `.gitignore`. This turned out to be a bad idea because tab-completing paths on the Vim command line doesn't work if the path is in `wildignore`. Worse, the built-in `expand()` returns null if the path you ask it to expand is in ignored. It took me a while to figure out that this was causing my `.gitignore`-ed host-specific `.vimlocal` file to not be sourced by my checked-in `.vimrc`.

### Buffers, buffers, buffers

I'm a staunch user of buffers. I've tried using tabs but never found them useful. All tabs do is create an additional way of hiding context from visibility, and they require you to memorize another keybinding or command to get at them. If you're using tmux, it's simply easier to open Vim in another pane. And if you're making good use of buffers, it's easy to get at the file you're thinking of with a few keystrokes using FZF as described above.

If you don't really use buffers, it's easy to understand: Once you start Vim, any file you open or create becomes a named buffer. You can view them using the `:buffers` command, and navigate to one of them using `:buf <name>`, where `<name>` is any part of the filename of the buffer. They also have numbers, which `:buffers` shows you, and you can refer to them that way.

If you start Vim from the command line with multiple files as command line arguments, each file will already be open in a buffer for easy access. If you've installed [vim-unimpaired](https://vimawesome.com/plugin/unimpaired-vim) you can use the <kbd>[</kbd><kbd>b</kbd> and <kbd>]</kbd><kbd>b</kbd> keybindings to navigate between them easily.

As I mentioned above, I've sped this process up considerably by binding the <kbd>;</kbd> key to the FZF `:Buffers` command so a single keystroke brings up a buffer list with fuzzy-finding. For example, if I open three files on the command line like `vim foo.txt bar.txt quux.txt`, getting to `quux.txt` is simply <kbd>;</kbd><kbd>q</kbd><kbd>Enter</kbd>. (Yes, using `:buf` is close, but fzf gives you a preview when you have many similarly-named files open.)

Sometimes I create buffers on accident, such as when trying to open a file with `:e` and hitting <kbd>Enter</kbd> too quickly. The `:bd` command can be used to delete the buffer and remove it from the list, but it will also close the Vim window or split if that buffer is open in it. A good solution is to use [bufkill.vim](https://vimawesome.com/plugin/bufkill-vim), which provides `:BD` to delete the current buffer but keeps the current window open. I use this a lot so I bound it to <kbd>Meta-w</kbd>.

Sometimes I need to do something external to a file, such as rename it or chmod it, but the open buffer in Vim gets out of sync. [NERDTree](https://github.com/scrooloose/nerdtree) will highlight the current file in the tree with `:NERDTreeFind`, and then I can hit <kbd>m</kbd> to modify it and choose an action like move or rename. A better solution is [vim-eunuch](https://vimawesome.com/plugin/eunuch-vim) which adds a host of commands to modify files but keep the buffers in sync: `:Chmod` chmods the current file, `:Rename` renames the file in its parent directory, `:Move` can move it to a new path, and `:Delete` will delete the file and the buffer. There are a few more commands but I've used those the most.

### Miscellaneous other plugins

A [friend](https://github.com/xonecas) turned me onto [vim-polyglot](https://vimawesome.com/plugin/vim-polyglot), which bundles 100+ syntax plugins into a single plugin and makes them load only on demand. It's kept very up to date, and the author has chosen the best syntax plugins for the most popular languages to make sure indenting and highlighting simply works.

Commenting out code is a common activity, so it makes sense to use a plugin that is smart enough to comment lines or blocks of code in multiple languages. You can usually get away with `:s/^/#` if you're writing code that uses hashes to comment out lines. I've found it easier to use the [vim-commentary](https://vimawesome.com/plugin/commentary-vim) plugin, which makes commenting and uncommenting in any language simple with <kbd>g</kbd><kbd>c</kbd>.

The [vim-surround](https://vimawesome.com/plugin/surround-vim) is so useful that it should probably be built into Vim. It adds keybindings to add, remove, and change the surrounding characters of any bit of text, such as changing single quotes to double quotes or brackets to parentheses. Unfortunately, by default, the <kbd>.</kbd> key doesn't repeat these changes, so you need [repeat.vim](https://vimawesome.com/plugin/repeat-vim) to make work. For example, to change the quotes used for multiple strings, use the <kbd>c</kbd><kbd>S</kbd><kbd>'</kbd><kbd>"</kbd> or similar combination once, then use <kbd>.</kbd> to repeat the substitution on the next string.

If you're writing Ruby or VimL or shell or any language with end-block statements, you'll be writing a lot of `end` and `endfunction` and `fi` statements. The [endwise](https://vimawesome.com/plugin/endwise-vim) plugin will insert them automatically, which saves time. And if you're writing HTML or XML, it makes sense to use [closetag.vim](https://vimawesome.com/plugin/closetag-vim) plugin which closes tags automatically when you type <kbd>&lt;</kbd><kbd>/</kbd>.

In the original post I mentioned some [tab and space fixing macros](/vim.html#other-peoples-code) which are handy when dealing with codebases that use different settings for tabs and spaces. However, [sleuth.vim](https://vimawesome.com/plugin/sleuth-vim) can detect these settings automatically and scans files when they're opened to figure out the indentation settings used. It works 90% of the time and pretty much removes the most uses of the macros I set up. I especially don't need to insert [modelines](https://vimhelp.appspot.com/options.txt.html#modeline) at the tops of files anymore.

### Vim isn't the only editor

It's worth talking about editors for a moment. Yes, I'm fully aware of the holy war nature of these arguments, but I feel that this decade we can at least agree on the right tool for the right job. We've never had such a swath of tools to get anything done -- editors, languages, frameworks, serialization formats -- so I think we're all a bit better about respecting other choices. (Is he kidding? That's an exercise for the reader.)

I've encountered a few handfuls of people over the years that are getting into programming, and inevitably they ask which text editor to use for writing code. My response is easy and immediate: Just use Sublime Text. It's a great editor, it's got a great plugin community with up-to-date syntax highlighting, and it works well on macOS, Windows, and Linux.

XXX pic of sublime text

Why is Sublime Text my first recommendation? Because learning Vim just adds extra overhead. If you're learning programming, a pedantic and brain-abrasive trade by default, learning the strange and seemingly-arcane combination _just to enter and edit text on the screen_ can be maddening. Sublime Text words like word processors for normal humans and is instantly useable.

I have a few more caveats, however. For Java, the leader is probably IntelliJ IDEA. Ten years ago it required a commercial license, but the free [Community Edition](XXX) is now available to anybody, and has the features a modern Java or Kotlin developer wants and needs, like Maven build support and Git integration. The real reasons to use IntelliJ with these languages is its amazing refactoring support, intelligent completion, [function signature annotations](XXX), smart indexing and searching (yes, way better than ctags), and its interactive debugger. In fact, when writing Ruby with JRuby, if I need to debug anything more than a simple `puts` will give me, I fire up IntelliJ and use the debugger. Besides, the free [IdeaVIM](XXX) plugin gives you Vim keybindings if you want them, and it works reasonably well.

XXX pic of intelli-J

Finally, [NeoVim](XXX) has caught my attention, but I'm far from making the switch. The big thing it advertised when it first came out was asynchronous function support, which has since been added in Vim 8. Other than that, I don't see a real advantage of using it over vanilla Vim, but I'm interested in seeing where it goes and who ends up using it.

### Conclusion

I hope this has been useful to you. Vim has been a major part of my prgoramming life, and it's probably responsible for the successful partrs of my career -- maybe even the unsuccessful parts where I wasted too much time.

I'm well past 30 years old now, which makes me about 150 in programmer years, and my focus now is on _getting stuff done_ instead of mucking about with my tools. But Vim is one of those tools where doing a little work and a little research, such as browsing [VimAwesome.com](XXX) or reading a few lines in a help page, can dramatically improve your effectiveness. In the most eggregious cases, when your brain needs a break from programming, it's usually pretty easy to think, "Hey, what's one thing that's really bugged me in Vim while I was doing X," and fine a solution for it quicikly.

I hope that this has been useful. Also check out my earlier posts, [Vim After 11 Years](XXX) and [Everything I Missed in _Vim After 11 Yeras_](XXX). Let me know what you think in the comments.
